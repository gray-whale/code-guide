import{_ as i,c as t,a2 as e,o as a}from"./chunks/framework.qADgyIdF.js";const f=JSON.parse('{"title":"如何处理定制化需求","description":"","frontmatter":{},"headers":[],"relativePath":"guide/git-custom.md","filePath":"guide/git-custom.md","lastUpdated":1700039457000}'),u={name:"guide/git-custom.md"};function o(r,l,s,c,n,d){return a(),t("div",null,l[0]||(l[0]=[e('<h1 id="如何处理定制化需求" tabindex="-1">如何处理定制化需求 <a class="header-anchor" href="#如何处理定制化需求" aria-label="Permalink to &quot;如何处理定制化需求&quot;">​</a></h1><ul><li>痛点 <ul><li>对于定制化需求, 并不会引入到正规的代码流中, 一般情况下会checkout出一个分支, 来专门做这里定制化需求, 然后单独发版. 使用分支模式的缺点有: <ul><li>更新问题 <ul><li>每次正规代码更新都要合并到该分支. 当分支较多时分支图就会比较混乱</li><li>正规代码合并是必然会带来风险的, 比如项目结构变动, 依赖库变动. 都可能导致定制化的代码失效</li></ul></li></ul></li></ul></li><li>解决办法 <ul><li>减少代码耦合 <ul><li>尽量将定制化需求模块化, 最小化和正规代码之间的接触面. 这是解决该问题最根本的方式. <ul><li>检验方式是结构变化时, 没有或很少适配代码</li></ul></li></ul></li><li>考虑通过代码层面区分 <ul><li>例如通过权限系统来配置. 通过后端接口动态配置</li></ul></li><li>优先使用fork模式 <ul><li>有些场景确实无法通过代码层面解决, 比如ios应用定制启动图, icon, 应用名称, 外观等等. 这种方式优先使用fork模式, fork模式和分支模式没本质区别, 但是至少可以避免干扰正规开发流程</li></ul></li></ul></li></ul>',2)]))}const p=i(u,[["render",o]]);export{f as __pageData,p as default};
